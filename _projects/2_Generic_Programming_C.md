---
title: "Generic Programming in C"
collection: projects
---

## Summary

A project aimed at implementing Generic Programming features as a design pattern in C, using pre-processor directives. This project involved the implementation of generic containers like list, stack, queue, vector and hashmap, iterators for each of these containers and generic algorithms like find, find_if, count, count_if, min, max, accumulate that make use of these iterators. This project was implemented as part of the Design Patterns Course during my Undergraduate Study.

## Implementation Details

The generic containers, iterators and generic algorithms have been implemented as a header file that the user can include as a library in their client program. These features have been implemented through the extensive use of pre-processor directives as explained below:
 * Generic Containers: The user can create an interface for a particular container and data type combination, for example LIST(double_l, double). In the background, the defined interface maps to the #define directives and results in the generation of the structures and functions required to define a list of double type and all its supported operations. Thus, double_l now represents a list of double type. This is essentially a new type that the user can use to declare  corresponding variables, like double_l l1. Consequently, this variable can be used to invoke the operations of a list, like l1.insert_at_beg(&l1, 5).
 * Iterators: The definition of an interface for a container and type also results in the creation of the iterator for that container and type combination. In the above example, double_l_iterator represents an iterator to a list of double type. This can be used to declare variables representing iterators like double_l_iterator it1 and can be used to invoke the operations supported for that iterator like it1.get_value(&it1). Every container includes the implementation of a specific type of iterator and its operations as mandated by the expected behaviour of that container. For example, the list iterator is implemented as a forward iterator supporting the equality, inequality, get_value, set_current, next, has_next and advance operations. 
 * Generic Algorithms: Adhering to the C++ concept of decoupling the containers and algorithms using iterators, the algorithms are implemented such that they are independent of the containers. The algorithms exclusively use iterators (a pair of iterators representing the operating range for the container under consideration) for implementing the required functionalities. Thereby, these algorithms are generic and can be invoked for any of the containers as long as the container supports an iterator of a specific type as mandated by the algorithm. For example, the find algorithm requires an input iterator at the very least for its functionality. Thereby, a list iterator which is implemented as a forward iterator can be used to invoke the find algorithm because a forward iterator is more powerful than an input iterator and supports all the functionalities expected for an input iterator.